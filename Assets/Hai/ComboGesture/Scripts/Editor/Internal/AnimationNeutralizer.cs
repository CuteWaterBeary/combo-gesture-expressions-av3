using System;
using System.Collections.Generic;
using System.Linq;
using Hai.ComboGesture.Scripts.Components;
using UnityEditor;
using UnityEditor.Animations;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Hai.ComboGesture.Scripts.Editor.Internal
{
    internal class AnimationNeutralizer
    {
        private readonly List<ActivityManifest> _originalActivityManifests;
        private readonly ConflictFxLayerMode _compilerConflictFxLayerMode;
        private readonly string _datetimeForAssetPack;

        public AnimationNeutralizer(List<ActivityManifest> originalActivityManifests, ConflictFxLayerMode compilerConflictFxLayerMode)
        {
            _originalActivityManifests = originalActivityManifests;
            _compilerConflictFxLayerMode = compilerConflictFxLayerMode;
            _datetimeForAssetPack = DateTime.Now.ToString("yyyy'-'MM'-'dd'_'HHmmss");
        }

        internal List<ActivityManifest> NeutralizeManifestAnimations()
        {
            var allAnimationClips = FindAllAnimationClips();
            var allAnimatedCurveKeys = FindAllCurveKeys(allAnimationClips);

            var remapping = CreateAssetContainerWithNeutralizedAnimations(allAnimationClips, allAnimatedCurveKeys);
            return _originalActivityManifests.Select(manifest => RemapManifest(manifest, remapping)).ToList();
        }

        private HashSet<AnimationClip> FindAllAnimationClips()
        {
            var allAnimationClips = _originalActivityManifests
                .SelectMany(manifest => manifest.Manifest.AnimationClips())
                .ToList();
            return new HashSet<AnimationClip>(allAnimationClips);
        }

        private static ActivityManifest RemapManifest(ActivityManifest manifest, Dictionary<AnimationClip, AnimationClip> remapping)
        {
            var remappedManifest = manifest.Manifest.NewFromRemappedAnimations(remapping);
            return new ActivityManifest(manifest.StageValue, remappedManifest, manifest.LayerOrdinal);
        }

        private Dictionary<AnimationClip, AnimationClip> CreateAssetContainerWithNeutralizedAnimations(HashSet<AnimationClip> allAnimationClips, HashSet<CurveKey> allAnimatedCurveKeys)
        {
            var remapping = new Dictionary<AnimationClip, AnimationClip>();
            var assetContainer = new AnimatorController();
            AssetDatabase.CreateAsset(assetContainer, "Assets/GeneratedCGE__" + _datetimeForAssetPack + ".asset");

            foreach (var animationClip in allAnimationClips)
            {
                var neutralizedAnimation = CopyAndNeutralize(animationClip, allAnimatedCurveKeys);
                AssetDatabase.AddObjectToAsset(neutralizedAnimation, assetContainer);

                remapping.Add(animationClip, neutralizedAnimation);
            }

            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();

            return remapping;
        }

        private AnimationClip CopyAndNeutralize(AnimationClip animationClipToBePreserved, HashSet<CurveKey> allAnimatedCurveKeys)
        {
            var copyOfAnimationClip = Object.Instantiate(animationClipToBePreserved);
            copyOfAnimationClip.name = "AUTOGENERATED_" + animationClipToBePreserved.name + "_DO_NOT_EDIT";

            var bindings = AnimationUtility.GetCurveBindings(copyOfAnimationClip);
            var thisAnimationPaths = bindings
                .Select(CurveKey.FromBinding)
                .ToList();

            foreach (var curveKey in allAnimatedCurveKeys)
            {
                if (!thisAnimationPaths.Contains(curveKey))
                {
                    Keyframe[] keyframes = {new Keyframe(0, 0), new Keyframe(1 / 60f, 0)};
                    var curve = new AnimationCurve(keyframes);
                    copyOfAnimationClip.SetCurve(curveKey.Path, curveKey.Type, curveKey.PropertyName, curve);
                }
            }

            if (_compilerConflictFxLayerMode != ConflictFxLayerMode.KeepBoth)
            {
                foreach (var curveKey in thisAnimationPaths)
                {
                    var isTransformOrMuscleCurve = IsTransformOrMuscleCurve(curveKey);
                    if (_compilerConflictFxLayerMode == ConflictFxLayerMode.KeepOnlyTransformsAndMuscles ? !isTransformOrMuscleCurve : isTransformOrMuscleCurve)
                    {
                        copyOfAnimationClip.SetCurve(curveKey.Path, curveKey.Type, curveKey.PropertyName, null);
                    }
                }
            }

            return copyOfAnimationClip;
        }

        struct CurveKey
        {
            public static CurveKey FromBinding(EditorCurveBinding binding)
            {
                return new CurveKey(binding.path, binding.type, binding.propertyName);
            }

            public CurveKey(string path, Type type, string propertyName)
            {
                Path = path;
                Type = type;
                PropertyName = propertyName;
            }

            public string Path { get; }
            public Type Type { get; }
            public string PropertyName { get; }

            public bool Equals(CurveKey other)
            {
                return Path == other.Path && Equals(Type, other.Type) && PropertyName == other.PropertyName;
            }

            public override bool Equals(object obj)
            {
                return obj is CurveKey other && Equals(other);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    var hashCode = (Path != null ? Path.GetHashCode() : 0);
                    hashCode = (hashCode * 397) ^ (Type != null ? Type.GetHashCode() : 0);
                    hashCode = (hashCode * 397) ^ (PropertyName != null ? PropertyName.GetHashCode() : 0);
                    return hashCode;
                }
            }
        }

        private HashSet<CurveKey> FindAllCurveKeys(HashSet<AnimationClip> allAnimationClips)
        {
            var curveKeys = allAnimationClips
                .SelectMany(AnimationUtility.GetCurveBindings)
                .Select(CurveKey.FromBinding)
                .Where(curveKey =>
                {
                    switch (_compilerConflictFxLayerMode)
                    {
                        case ConflictFxLayerMode.RemoveTransformsAndMuscles: return !IsTransformOrMuscleCurve(curveKey);
                        case ConflictFxLayerMode.KeepBoth: return true;
                        case ConflictFxLayerMode.KeepOnlyTransformsAndMuscles: return IsTransformOrMuscleCurve(curveKey);
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                })
                .ToList();

            return new HashSet<CurveKey>(curveKeys);
        }

        private static bool IsTransformOrMuscleCurve(CurveKey curveKey)
        {
            return curveKey.Type == typeof(Transform) || curveKey.Type == typeof(Animator);
        }
    }
}
